# Именованные события: программируем GUI

В настоящее время большинство сайтов представляют собой по сути обычную программу, которая обрабатывает те или иные действия пользователей. Для того чтобы упрощать жизнь программистам реализованы десятки фреймворков помогающих решать те или иные задачи.

Если рассматривать программирование GUI или UI вообще, то в обобщенном случае UI представляет собой множество **слабосвязанных** задач в одном пакете. 

Например раздел "погода" на главной страничке поисковика - является просто индикатором. Выбрав тему - мы можем увидеть дождик или солнышко на фоне. Нужно ли устанавливать взаимосвязь между разделом "погода" и фоновой картинкой? С точки зрения минимизации компьютерных расходов - безусловно: хорошо повторно использовать данные полученные однажды. Однако с точки зрения разработки программирование слабосвязанных вещей может тянуть за собой настолько большие трудозатраты, что иногда проще отказаться от связанности и два раза запросить одни и те же данные.

О программировании слабосвязанных вещей попробуем поговорить в данной статье.

</cut>

Сразу обращаю внимание, что данная статья ставит целью **описать подход к решению** задачи, поэтому некоторая часть кода приведённого в статье может выглядеть "велосипедно", либо Вы можете указать ссылку на более профессиональную реализацию.

Итак, поскольку мы с самого начала статьи сформулировали термин "слабосвязанный", то логично будет поисследовать уровень связи в разных подходах.

Рассмотрим в начале обычный функциональный или ООП подход:

Объект (или процесс) А вызывает метод у объекта (или процесса) B.
Здесь по отношению к данным возможны два варианта запросный и уведомительный:

1. Блок с погодой уведомляет блок с темой: "сейчас +8 градусов, дождь".
2. Блок с темой опрашивает блок с погодой: "какая сейчас погода?" и в ответ получает "+8 градусов, дождь".

Очевидно, в данном случае мы имеем пример сильной взаимосвязи: 

* в первом случае блок с погодой "знает" что еще существует блок с темой и занимается его уведомлением;
* во втором случае блок с темой "знает" о блоке погоды.

Если удалить из игры по каким-то причинам один из блоков, то чтобы второй продолжил работать корректно - требуется предпринимать специальные действия.

Если в игру ввести 2-3 дополнительных блока-источника данных и 2-3 дополнительных блока-потребителя данных, то сложность программирования взаимосвязей резко возрастает.

Рефлексия над проблемой неизбежно приводит к следующему:

1. Производится смешение запросно-уведомительного вариантов: publish/subscribe вариант (это касается не столько "силы" взаимосвязи, сколько качества)
2. Требуется некоторое обобщение, позволяющее собирать в кучу слабосвязанные: некая библиотека, которая позволит относительно просто решать проблемы взаимосвязей.

Хочется программировать блок "погоды" так, чтобы в его коде было минимум информации о том что имеется еще блок "тема" и прочие блоки. 

Если мы обратимся из мира веб-программирования в мир большого GUI, например - операционные системы, то увидим что там сталкиваются с тем же набором проблем, а  поскольку сталкиваются в гораздо больших объемах, то возможно и решения там имеются хорошо проработанные на концептуальном уровне?
Обычный GUI пользователя операционной системы реагирует на сотни внешних "раздражителей": наличие подключенного источника питания, включенный доступ в интернет, выбранный язык итп итд.

В каждой операционной системе существует решение, позволяющей связывать между собой слабосвязанные вещи. В Linux этим решением является DBUS.
Как это работает? Когда пользователь закрывает крышку ноутбука или когда сетевой интерфейс производит подключение к внешнему миру, то в шину DBUS отправляется сообщение.

Теперь коду, который работает с крышкой ноутбука не нужно иметь связь со всеми связанными компонентами (которые могут присутствовать, могут отсутствовать), а достаточно сообщать в системную шину данные о себе. Множество устройств наполняют системную шину сообщениями:

- (драйвер крышки) если кому-то интересно, то крышка ноутбука открыта!
- (сетевая карта) возможно это неинтересно никому, но соединение с внешним миром установлено!
- (плеер) я здесь показываю фильм пользователю!
- (датчик температуры) у меня 69 градусов!
- (драйвер USB) у меня тут флешку воткнули!
- (плеер) я все еще показываю фильм пользователю!

Несколько утрировано и несколько оторвано от реальности, но наглядно :)

Теперь если мы хотим понимания что происходит в системе, мы просто слушаем эту шину. А если хотим интегрироваться с системой, то начинаем и отправлять данные в эту шину.
